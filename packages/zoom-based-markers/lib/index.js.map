{"version":3,"sources":["../src/index.tsx"],"names":["getTransformedSymbol","symbolEntry","symbolTransform","symbolByType","newEntry","Object","entries","forEach","key","originalSymbol","symbol","getSymbolEntry","symbols","zoom","reduce","bestMarker","marker","minZoom","ZoomBasedMarkers","entities","length","renderedMarkers","transformedEntry","getType","DefaultSymbol","map","entity","EntitySymbol","id","Math","floor"],"mappings":";;;;;;;;;AAAA;;AACA;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA,MAAMA,oBAAoB,GAAG,CAC3BC,WAD2B,EAE3BC,eAF2B,KAGxB;AACH;AACA,MAAI,OAAOA,eAAP,KAA2B,UAA/B,EAA2C;AACzC,WAAOD,WAAP;AACD;;AAED,QAAM;AAAEE,IAAAA;AAAF,MAAmBF,WAAzB;AACA,QAAMG,QAAQ,GAAG,qBAAUH,WAAV,CAAjB;;AAEA,MAAIE,YAAJ,EAAkB;AAChB;AACAE,IAAAA,MAAM,CAACC,OAAP,CAAeH,YAAf,EAA6BI,OAA7B,CAAqC,CAAC,CAACC,GAAD,EAAMC,cAAN,CAAD,KAA2B;AAC9DL,MAAAA,QAAQ,CAACD,YAAT,CAAsBK,GAAtB,IAA6BN,eAAe,CAACO,cAAD,CAA5C;AACD,KAFD;AAGD,GAdE,CAgBH;;;AACAL,EAAAA,QAAQ,CAACM,MAAT,GAAkBR,eAAe,CAACD,WAAW,CAACS,MAAb,CAAjC;AACA,SAAON,QAAP;AACD,CAtBD;AAwBA;AACA;AACA;AACA;;;AACA,MAAMO,cAAc,GAAG,CAACC,OAAD,EAA6BC,IAA7B,KACrBD,OADqB,aACrBA,OADqB,uBACrBA,OAAO,CAAEE,MAAT,CAAgB,CAACC,UAAD,EAAaC,MAAb,KAAwB;AACtC,MAAIH,IAAI,IAAIG,MAAM,CAACC,OAAnB,EAA4B;AAC1B,QAAI,CAACF,UAAD,IAAeC,MAAM,CAACC,OAAP,GAAiBF,UAAU,CAACE,OAA/C,EAAwD;AACtD,aAAOD,MAAP;AACD;AACF;;AACD,SAAOD,UAAP;AACD,CAPD,EAOG,IAPH,CADF;;AAkCA;AACA;AACA;AACA,MAAMG,gBAAgB,GAAG,CAAC;AACxBC,EAAAA,QADwB;AAExBP,EAAAA,OAFwB;AAGxBV,EAAAA,eAHwB;AAIxBW,EAAAA;AAJwB,CAAD,KAKC;AACxB,MAAI,CAACM,QAAD,IAAa,CAACA,QAAQ,CAACC,MAA3B,EAAmC,OAAO,IAAP,CADX,CAGxB;;AACA,QAAMnB,WAAW,GAAGU,cAAc,CAACC,OAAD,EAAUC,IAAV,CAAlC,CAJwB,CAMxB;AACA;;AACA,MAAIQ,eAAe,GAAG,IAAtB;;AACA,MAAIpB,WAAJ,EAAiB;AACf,UAAMqB,gBAAgB,GAAGtB,oBAAoB,CAACC,WAAD,EAAcC,eAAd,CAA7C;AAEA,UAAM;AAAEqB,MAAAA,OAAF;AAAWb,MAAAA,MAAM,EAAEc,aAAnB;AAAkCrB,MAAAA;AAAlC,QAAmDmB,gBAAzD,CAHe,CAIf;AACA;;AAEAD,IAAAA,eAAe,GAAG,oBAChB,MACEF,QAAQ,CAACM,GAAT,CAAaC,MAAM,IAAI;AACrB,YAAMC,YAAY,GACfJ,OAAO,IAAIpB,YAAY,CAACoB,OAAO,CAACG,MAAD,CAAR,CAAxB,IAA8CF,aADhD;AAEA,aACEG,YAAY,iBACV,6BAAC,YAAD;AACE,QAAA,MAAM,EAAED,MADV;AAEE,QAAA,GAAG,EAAEA,MAAM,CAACE,EAFd;AAGE,QAAA,IAAI,EAAEC,IAAI,CAACC,KAAL,CAAWjB,IAAX;AAHR,QAFJ;AASD,KAZD,CAFc,EAehB,CAACM,QAAD,EAAWN,IAAX,CAfgB,CAAlB;AAiBD;;AAED,SAAOQ,eAAP;AACD,CAzCD;;eA2CeH,gB","sourcesContent":["import cloneDeep from \"lodash.clonedeep\";\nimport React, { useMemo } from \"react\";\nimport {\n  LayerEntity,\n  SymbolComponent,\n  ZoomBasedSymbol\n} from \"@opentripplanner/types\";\n\n/**\n * Transforms the symbol and symbols by type from the specified symbolEntry\n * using the specified symbolTransform.\n * TODO: Should this be memoized?\n */\nconst getTransformedSymbol = (\n  symbolEntry: ZoomBasedSymbol,\n  symbolTransform: (symbol: SymbolComponent) => SymbolComponent\n) => {\n  // If no transform function provided, just return symbolEntry.\n  if (typeof symbolTransform !== \"function\") {\n    return symbolEntry;\n  }\n\n  const { symbolByType } = symbolEntry;\n  const newEntry = cloneDeep(symbolEntry);\n\n  if (symbolByType) {\n    // Transform entries in symbolByType.\n    Object.entries(symbolByType).forEach(([key, originalSymbol]) => {\n      newEntry.symbolByType[key] = symbolTransform(originalSymbol);\n    });\n  }\n\n  // Transform the main (default) symbol.\n  newEntry.symbol = symbolTransform(symbolEntry.symbol);\n  return newEntry;\n};\n\n/**\n * Finds the deepest symbol (the symbol associated with the highest minZoom)\n * for the specified symbols and zoom level.\n */\nconst getSymbolEntry = (symbols: ZoomBasedSymbol[], zoom: number) =>\n  symbols?.reduce((bestMarker, marker) => {\n    if (zoom >= marker.minZoom) {\n      if (!bestMarker || marker.minZoom > bestMarker.minZoom) {\n        return marker;\n      }\n    }\n    return bestMarker;\n  }, null);\n\ntype Props = {\n  /**\n   * A list of objects (entities) to be rendered on the map.\n   * Entities must have an id attribute and contain coordinates information for correct placement.\n   */\n  entities: LayerEntity[];\n  /**\n   * A list of symbols that represent the entities at the associated zoom level.\n   * The symbols must be able to obtain the position of the specified entities.\n   * (The list does not need to be sorted.)\n   */\n  symbols: ZoomBasedSymbol[];\n  /**\n   * An optional function(Component) to transforms components defined in the symbols prop prior to rendering,\n   * in cases you need to wrap symbols or inject children.\n   * The function must return a component that accepts these props: ({ entity, zoom }).\n   * In addition, to inject children, the returned component must explicitly render any applicable children passed to it.\n   */\n  symbolTransform?: (symbol: SymbolComponent) => SymbolComponent;\n  /**\n   * The current zoom level for rendering.\n   */\n  zoom: number;\n};\n/**\n * A component that renders different components based on zoom level.\n */\nconst ZoomBasedMarkers = ({\n  entities,\n  symbols,\n  symbolTransform,\n  zoom\n}: Props): JSX.Element => {\n  if (!entities || !entities.length) return null;\n\n  // Find the deepest symbol for the current zoom level.\n  const symbolEntry = getSymbolEntry(symbols, zoom);\n\n  // With that symbol entry, transform its symbols (if a symbolTransform prop is provided),\n  // and use the transformed symbols to render the entities.\n  let renderedMarkers = null;\n  if (symbolEntry) {\n    const transformedEntry = getTransformedSymbol(symbolEntry, symbolTransform);\n\n    const { getType, symbol: DefaultSymbol, symbolByType } = transformedEntry;\n    // Note that the result of the transformed symbols can be null (even for DefaultSymbol),\n    // hence the null checks before the return statements below.\n\n    renderedMarkers = useMemo(\n      () =>\n        entities.map(entity => {\n          const EntitySymbol =\n            (getType && symbolByType[getType(entity)]) || DefaultSymbol;\n          return (\n            EntitySymbol && (\n              <EntitySymbol\n                entity={entity}\n                key={entity.id}\n                zoom={Math.floor(zoom)}\n              />\n            )\n          );\n        }),\n      [entities, zoom]\n    );\n  }\n\n  return renderedMarkers;\n};\n\nexport default ZoomBasedMarkers;\n"],"file":"index.js"}