{"version":3,"sources":["../src/index.tsx"],"names":["cloneDeep","React","useMemo","getTransformedSymbol","symbolEntry","symbolTransform","symbolByType","newEntry","Object","entries","forEach","key","originalSymbol","symbol","getSymbolEntry","symbols","zoom","reduce","bestMarker","marker","minZoom","ZoomBasedMarkers","entities","length","renderedMarkers","transformedEntry","getType","DefaultSymbol","map","entity","EntitySymbol","id","Math","floor"],"mappings":"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","sourcesContent":["import cloneDeep from \"lodash.clonedeep\";\nimport React, { useMemo } from \"react\";\nimport {\n  LayerEntity,\n  SymbolComponent,\n  ZoomBasedSymbol\n} from \"@opentripplanner/types\";\n\n/**\n * Transforms the symbol and symbols by type from the specified symbolEntry\n * using the specified symbolTransform.\n * TODO: Should this be memoized?\n */\nconst getTransformedSymbol = (\n  symbolEntry: ZoomBasedSymbol,\n  symbolTransform: (symbol: SymbolComponent) => SymbolComponent\n) => {\n  // If no transform function provided, just return symbolEntry.\n  if (typeof symbolTransform !== \"function\") {\n    return symbolEntry;\n  }\n\n  const { symbolByType } = symbolEntry;\n  const newEntry = cloneDeep(symbolEntry);\n\n  if (symbolByType) {\n    // Transform entries in symbolByType.\n    Object.entries(symbolByType).forEach(([key, originalSymbol]) => {\n      newEntry.symbolByType[key] = symbolTransform(originalSymbol);\n    });\n  }\n\n  // Transform the main (default) symbol.\n  newEntry.symbol = symbolTransform(symbolEntry.symbol);\n  return newEntry;\n};\n\n/**\n * Finds the deepest symbol (the symbol associated with the highest minZoom)\n * for the specified symbols and zoom level.\n */\nconst getSymbolEntry = (symbols: ZoomBasedSymbol[], zoom: number) =>\n  symbols?.reduce((bestMarker, marker) => {\n    if (zoom >= marker.minZoom) {\n      if (!bestMarker || marker.minZoom > bestMarker.minZoom) {\n        return marker;\n      }\n    }\n    return bestMarker;\n  }, null);\n\ntype Props = {\n  /**\n   * A list of objects (entities) to be rendered on the map.\n   * Entities must have an id attribute and contain coordinates information for correct placement.\n   */\n  entities: LayerEntity[];\n  /**\n   * A list of symbols that represent the entities at the associated zoom level.\n   * The symbols must be able to obtain the position of the specified entities.\n   * (The list does not need to be sorted.)\n   */\n  symbols: ZoomBasedSymbol[];\n  /**\n   * An optional function(Component) to transforms components defined in the symbols prop prior to rendering,\n   * in cases you need to wrap symbols or inject children.\n   * The function must return a component that accepts these props: ({ entity, zoom }).\n   * In addition, to inject children, the returned component must explicitly render any applicable children passed to it.\n   */\n  symbolTransform?: (symbol: SymbolComponent) => SymbolComponent;\n  /**\n   * The current zoom level for rendering.\n   */\n  zoom: number;\n};\n/**\n * A component that renders different components based on zoom level.\n */\nconst ZoomBasedMarkers = ({\n  entities,\n  symbols,\n  symbolTransform,\n  zoom\n}: Props): JSX.Element => {\n  if (!entities || !entities.length) return null;\n\n  // Find the deepest symbol for the current zoom level.\n  const symbolEntry = getSymbolEntry(symbols, zoom);\n\n  // With that symbol entry, transform its symbols (if a symbolTransform prop is provided),\n  // and use the transformed symbols to render the entities.\n  let renderedMarkers = null;\n  if (symbolEntry) {\n    const transformedEntry = getTransformedSymbol(symbolEntry, symbolTransform);\n\n    const { getType, symbol: DefaultSymbol, symbolByType } = transformedEntry;\n    // Note that the result of the transformed symbols can be null (even for DefaultSymbol),\n    // hence the null checks before the return statements below.\n\n    renderedMarkers = useMemo(\n      () =>\n        entities.map(entity => {\n          const EntitySymbol =\n            (getType && symbolByType[getType(entity)]) || DefaultSymbol;\n          return (\n            EntitySymbol && (\n              <EntitySymbol\n                entity={entity}\n                key={entity.id}\n                zoom={Math.floor(zoom)}\n              />\n            )\n          );\n        }),\n      [entities, zoom]\n    );\n  }\n\n  return renderedMarkers;\n};\n\nexport default ZoomBasedMarkers;\n"],"file":"index.js"}