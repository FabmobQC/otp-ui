{"version":3,"sources":["../src/index.tsx"],"names":["util","LngLatBounds","Layer","Source","useMap","React","useEffect","polyline","pointInPolygon","objectExistsAndPopulated","isGeometryComplete","routeData","patterns","Object","values","every","ptn","geometry","removePointsInFlexZone","stops","points","bboxes","map","stop","geometries","geoJson","type","coordinates","filter","bbox","y","x","reduceBounds","bnds","coord","extend","RouteViewerOverlay","props","current","bounds","timeout","allPoints","reduce","acc","concat","decode","length","geoJsonedPoints","c","forEach","coordsArray","coords","fitBounds","fitMapBounds","setTimeout","mapCenterCallback","clearTimeout","clipToPatternStops","path","routeColor","color","segments","pattern","pts","clippedPts","pt","geojson","features","segment","properties","opacity","weight"],"mappings":"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","sourcesContent":["import { util } from \"@opentripplanner/base-map\";\nimport { Stop } from \"@opentripplanner/types\";\nimport { LngLatBounds } from \"maplibre-gl\";\nimport { Layer, LngLatLike, Source, useMap } from \"react-map-gl\";\nimport React, { useEffect } from \"react\";\n\nimport polyline from \"@mapbox/polyline\";\nimport pointInPolygon from \"point-in-polygon\";\nimport { objectExistsAndPopulated } from \"./util\";\n\ntype RouteData = {\n  color?: string;\n  patterns: Record<\n    string,\n    {\n      id: string;\n      name?: string;\n      geometry?: { points: [number, number][] };\n      stops?: Stop[];\n    }\n  >;\n};\n\ntype Props = {\n  /**\n   * If pattern stops contain polygons, we can request that the routes are not drawn\n   * inside of these polygons by setting this prop to true. If true, the layer will\n   * check every zone of every stop in a pattern before drawing the route for that pattern\n   * and only draw the route outside of the polygon.\n   */\n  clipToPatternStops?: boolean;\n  /**\n   * This method is called whenever the bounds are updated to fit a route\n   */\n  mapCenterCallback: () => void;\n  /**\n   * Some Leaflet properties that have been mapped to MapLibreGL\n   * TODO: expose MapLibre properties?\n   */\n  path?: { color?: string; opacity?: number; weight?: number };\n  /**\n   * This represents data about a route as obtained from a transit index.\n   * Typically a route has more data than these items, so this is only a list of\n   * the properties that this component actually uses.\n   */\n  routeData: RouteData;\n};\n\n// helper fn to check if geometry has been populated for all patterns in route\nconst isGeometryComplete = (routeData: RouteData) =>\n  routeData?.patterns &&\n  Object.values(routeData.patterns).every(\n    ptn => typeof ptn?.geometry !== \"undefined\"\n  );\n\n/**\n * helper function that removes all points from array of points that are\n * within flex zones defined in an array of stops\n * @param {*} stops   OTP stops response\n * @param {*} points  Array of coordinates to clip\n * @returns           The array of coordinates without coordinates within the stops\n */\nconst removePointsInFlexZone = (stops: Stop[], points: [number, number][]) => {\n  // First, go through all stops to find flex zones\n  const bboxes =\n    stops\n      // Although it is less clean, doing a single map with many if conditions\n      // is much faster than adding multiple filters (as the array is iterated over fewer times)\n      // Adding a separate filter would increase the time spent processing the array, which\n      // needs to be kept to a minimum as this is happening inside render()\n      // For more detail see https://github.com/dg92/Performance-Analysis-JS/blob/master/small_data_set_result.png\n      ?.map(stop => {\n        if (stop.geometries?.geoJson?.type !== \"Polygon\") {\n          return null;\n        }\n        return stop.geometries.geoJson.coordinates?.[0] || null;\n      })\n      // Remove the null entries\n      // This filter is required, as there is no way to have map not return a value\n      .filter(bbox => !!bbox) || [];\n\n  // Points we keep can't be in any of the flex zones\n  return points.filter(([y, x]) =>\n    bboxes.every(bbox => !pointInPolygon([x, y], bbox))\n  );\n};\n\n/**\n * Reducer helper for computing the bounds of a geometry.\n */\nconst reduceBounds = (bnds, coord) => bnds.extend(coord);\n\n/**\n * An overlay that will display all polylines of the patterns of a route.\n */\nconst RouteViewerOverlay = (props: Props): JSX.Element => {\n  const { current } = useMap();\n  const { routeData } = props;\n  const patterns = Object.values(routeData.patterns);\n  useEffect(() => {\n    // if pattern geometry updated, update the map points\n    let bounds;\n    let timeout;\n    if (isGeometryComplete(routeData)) {\n      const allPoints: LngLatLike[] = patterns.reduce((acc, ptn) => {\n        return acc.concat(polyline.decode(ptn.geometry.points));\n      }, []);\n\n      if (allPoints.length > 0) {\n        const geoJsonedPoints: [number, number][] = allPoints.map(c => {\n          return [c[1], c[0]];\n        });\n        bounds = geoJsonedPoints.reduce(\n          reduceBounds,\n          new LngLatBounds(geoJsonedPoints[0], geoJsonedPoints[0])\n        );\n      }\n    }\n\n    patterns.forEach(ptn => {\n      ptn.stops?.forEach(stop => {\n        const { geoJson } = stop.geometries || {};\n        if (geoJson?.type === \"Polygon\") {\n          // If flex location, add the polygon (the first and only entry in coordinates) to the route bounds.\n          const coordsArray = geoJson.coordinates[0];\n          bounds = coordsArray.reduce(\n            reduceBounds,\n            bounds || new LngLatBounds(coordsArray[0], coordsArray[0])\n          );\n        } else if (geoJson) {\n          // Regular stops might be (well) outside of route pattern shapes, so add them.\n          const coords = geoJson.coordinates;\n          bounds = bounds\n            ? bounds.extend(coords)\n            : new LngLatBounds(coords, coords);\n        }\n      });\n    });\n\n    if (objectExistsAndPopulated(bounds) && current) {\n      // Try to fit the map to route bounds immediately. If other overlays are still populating contents\n      // and/or the map skips/aborts fitting for any reason, try fitting bounds again after a short delay.\n      const fitBounds = () => util.fitMapBounds(current, bounds);\n      fitBounds();\n      timeout = setTimeout(fitBounds, 250);\n      if (props.mapCenterCallback) {\n        props.mapCenterCallback();\n      }\n    }\n\n    // Clear any timeouts when the component unmounts.\n    return () => clearTimeout(timeout);\n  }, [routeData, patterns, current]);\n\n  const { clipToPatternStops, path } = props;\n\n  // Null can't be returned here -- react-map-gl dislikes null values as children\n  if (!routeData || !routeData.patterns) return <></>;\n\n  const routeColor = routeData.color\n    ? `#${routeData.color}`\n    : path?.color || \"#00bfff\";\n  const segments = patterns\n    .filter(pattern => objectExistsAndPopulated(pattern?.geometry))\n    .map(pattern => {\n      const pts = polyline.decode(pattern.geometry.points);\n      const clippedPts = clipToPatternStops\n        ? removePointsInFlexZone(pattern?.stops, pts)\n        : pts;\n\n      return clippedPts.map((pt: [number, number]) => [pt[1], pt[0]]);\n    });\n\n  const geojson: GeoJSON.FeatureCollection = {\n    type: \"FeatureCollection\",\n    features: segments.map(segment => ({\n      type: \"Feature\",\n      geometry: { type: \"LineString\", coordinates: segment },\n      properties: []\n    }))\n  };\n\n  return segments.length > 0 ? (\n    <Source id=\"route\" type=\"geojson\" data={geojson}>\n      <Layer\n        id=\"route\"\n        layout={{\n          \"line-cap\": \"round\",\n          \"line-join\": \"round\"\n        }}\n        paint={{\n          \"line-color\": path?.color || routeColor,\n          \"line-opacity\": path?.opacity || 1,\n          \"line-width\": path?.weight || 3\n        }}\n        type=\"line\"\n      />\n    </Source>\n  ) : (\n    <></>\n  );\n};\n\nexport default RouteViewerOverlay;\n"],"file":"index.js"}