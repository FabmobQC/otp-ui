{"version":3,"sources":["../src/index.tsx"],"names":["isGeometryComplete","routeData","patterns","Object","values","every","ptn","geometry","removePointsInFlexZone","stops","points","bboxes","map","stop","geometries","geoJson","type","coordinates","filter","bbox","y","x","reduceBounds","bnds","coord","extend","RouteViewerOverlay","props","current","bounds","timeout","allPoints","reduce","acc","concat","polyline","decode","length","geoJsonedPoints","c","LngLatBounds","forEach","coordsArray","coords","fitBounds","util","fitMapBounds","setTimeout","mapCenterCallback","clearTimeout","clipToPatternStops","path","routeColor","color","segments","pattern","pts","clippedPts","pt","geojson","features","segment","properties","opacity","weight"],"mappings":"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","sourcesContent":["import { util } from \"@opentripplanner/base-map\";\nimport { Stop } from \"@opentripplanner/types\";\nimport { LngLatBounds } from \"maplibre-gl\";\nimport { Layer, LngLatLike, Source, useMap } from \"react-map-gl\";\nimport React, { useEffect } from \"react\";\n\nimport polyline from \"@mapbox/polyline\";\nimport pointInPolygon from \"point-in-polygon\";\nimport { objectExistsAndPopulated } from \"./util\";\n\ntype RouteData = {\n  color?: string;\n  patterns: Record<\n    string,\n    {\n      id: string;\n      name?: string;\n      geometry?: { points: [number, number][] };\n      stops?: Stop[];\n    }\n  >;\n};\n\ntype Props = {\n  /**\n   * If pattern stops contain polygons, we can request that the routes are not drawn\n   * inside of these polygons by setting this prop to true. If true, the layer will\n   * check every zone of every stop in a pattern before drawing the route for that pattern\n   * and only draw the route outside of the polygon.\n   */\n  clipToPatternStops?: boolean;\n  /**\n   * This method is called whenever the bounds are updated to fit a route\n   */\n  mapCenterCallback: () => void;\n  /**\n   * Some Leaflet properties that have been mapped to MapLibreGL\n   * TODO: expose MapLibre properties?\n   */\n  path?: { color?: string; opacity?: number; weight?: number };\n  /**\n   * This represents data about a route as obtained from a transit index.\n   * Typically a route has more data than these items, so this is only a list of\n   * the properties that this component actually uses.\n   */\n  routeData: RouteData;\n};\n\n// helper fn to check if geometry has been populated for all patterns in route\nconst isGeometryComplete = (routeData: RouteData) =>\n  routeData?.patterns &&\n  Object.values(routeData.patterns).every(\n    ptn => typeof ptn?.geometry !== \"undefined\"\n  );\n\n/**\n * helper function that removes all points from array of points that are\n * within flex zones defined in an array of stops\n * @param {*} stops   OTP stops response\n * @param {*} points  Array of coordinates to clip\n * @returns           The array of coordinates without coordinates within the stops\n */\nconst removePointsInFlexZone = (stops: Stop[], points: [number, number][]) => {\n  // First, go through all stops to find flex zones\n  const bboxes =\n    stops\n      // Although it is less clean, doing a single map with many if conditions\n      // is much faster than adding multiple filters (as the array is iterated over fewer times)\n      // Adding a separate filter would increase the time spent processing the array, which\n      // needs to be kept to a minimum as this is happening inside render()\n      // For more detail see https://github.com/dg92/Performance-Analysis-JS/blob/master/small_data_set_result.png\n      ?.map(stop => {\n        if (stop.geometries?.geoJson?.type !== \"Polygon\") {\n          return null;\n        }\n        return stop.geometries.geoJson.coordinates?.[0] || null;\n      })\n      // Remove the null entries\n      // This filter is required, as there is no way to have map not return a value\n      .filter(bbox => !!bbox) || [];\n\n  // Points we keep can't be in any of the flex zones\n  return points.filter(([y, x]) =>\n    bboxes.every(bbox => !pointInPolygon([x, y], bbox))\n  );\n};\n\n/**\n * Reducer helper for computing the bounds of a geometry.\n */\nconst reduceBounds = (bnds, coord) => bnds.extend(coord);\n\n/**\n * An overlay that will display all polylines of the patterns of a route.\n */\nconst RouteViewerOverlay = (props: Props): JSX.Element => {\n  const { current } = useMap();\n  const { routeData } = props;\n  const patterns = Object.values(routeData.patterns);\n  useEffect(() => {\n    // if pattern geometry updated, update the map points\n    let bounds;\n    let timeout;\n    if (isGeometryComplete(routeData)) {\n      const allPoints: LngLatLike[] = patterns.reduce((acc, ptn) => {\n        return acc.concat(polyline.decode(ptn.geometry.points));\n      }, []);\n\n      if (allPoints.length > 0) {\n        const geoJsonedPoints: [number, number][] = allPoints.map(c => {\n          return [c[1], c[0]];\n        });\n        bounds = geoJsonedPoints.reduce(\n          reduceBounds,\n          new LngLatBounds(geoJsonedPoints[0], geoJsonedPoints[0])\n        );\n      }\n    }\n\n    patterns.forEach(ptn => {\n      ptn.stops?.forEach(stop => {\n        const { geoJson } = stop.geometries || {};\n        if (geoJson?.type === \"Polygon\") {\n          // If flex location, add the polygon (the first and only entry in coordinates) to the route bounds.\n          const coordsArray = geoJson.coordinates[0];\n          bounds = coordsArray.reduce(\n            reduceBounds,\n            bounds || new LngLatBounds(coordsArray[0], coordsArray[0])\n          );\n        } else if (geoJson) {\n          // Regular stops might be (well) outside of route pattern shapes, so add them.\n          const coords = geoJson.coordinates;\n          bounds = bounds\n            ? bounds.extend(coords)\n            : new LngLatBounds(coords, coords);\n        }\n      });\n    });\n\n    if (objectExistsAndPopulated(bounds) && current) {\n      // Try to fit the map to route bounds immediately. If other overlays are still populating contents\n      // and/or the map skips/aborts fitting for any reason, try fitting bounds again after a short delay.\n      const fitBounds = () => util.fitMapBounds(current, bounds);\n      fitBounds();\n      timeout = setTimeout(fitBounds, 250);\n      if (props.mapCenterCallback) {\n        props.mapCenterCallback();\n      }\n    }\n\n    // Clear any timeouts when the component unmounts.\n    return () => clearTimeout(timeout);\n  }, [routeData, patterns, current]);\n\n  const { clipToPatternStops, path } = props;\n\n  // Null can't be returned here -- react-map-gl dislikes null values as children\n  if (!routeData || !routeData.patterns) return <></>;\n\n  const routeColor = routeData.color\n    ? `#${routeData.color}`\n    : path?.color || \"#00bfff\";\n  const segments = patterns\n    .filter(pattern => objectExistsAndPopulated(pattern?.geometry))\n    .map(pattern => {\n      const pts = polyline.decode(pattern.geometry.points);\n      const clippedPts = clipToPatternStops\n        ? removePointsInFlexZone(pattern?.stops, pts)\n        : pts;\n\n      return clippedPts.map((pt: [number, number]) => [pt[1], pt[0]]);\n    });\n\n  const geojson: GeoJSON.FeatureCollection = {\n    type: \"FeatureCollection\",\n    features: segments.map(segment => ({\n      type: \"Feature\",\n      geometry: { type: \"LineString\", coordinates: segment },\n      properties: []\n    }))\n  };\n\n  return segments.length > 0 ? (\n    <Source id=\"route\" type=\"geojson\" data={geojson}>\n      <Layer\n        id=\"route\"\n        layout={{\n          \"line-cap\": \"round\",\n          \"line-join\": \"round\"\n        }}\n        paint={{\n          \"line-color\": path?.color || routeColor,\n          \"line-opacity\": path?.opacity || 1,\n          \"line-width\": path?.weight || 3\n        }}\n        type=\"line\"\n      />\n    </Source>\n  ) : (\n    <></>\n  );\n};\n\nexport default RouteViewerOverlay;\n"],"file":"index.js"}