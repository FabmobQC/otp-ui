{"version":3,"sources":["../../src/geocoders/noapi.ts"],"names":["NoApiGeocoder","Geocoder","autocomplete","query","parseCoordinateString","text","reverse","lat","lon","point","roundGPSDecimal","feature","geometry","coordinates","type","properties","name","geocoderConfig","reverseUseFeatureCollection","Promise","resolve","features","rawGeocodedFeature","search","string","label","e","number","roundFactor","Math","round"],"mappings":";;;;;;;;;AAAA;;AAQA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACe,MAAMA,aAAN,SAA4BC,yBAA5B,CAAqC;AAClD;AACF;AACA;AACEC,EAAAA,YAAY,CAACC,KAAD,EAA2D;AACrE,WAAO,KAAKC,qBAAL,CAA2BD,KAAK,CAACE,IAAjC,CAAP;AACD;AAED;AACF;AACA;;;AACEC,EAAAA,OAAO,CAACH,KAAD,EAA8D;AAAA;;AACnE,QAAI;AAAEI,MAAAA,GAAF;AAAOC,MAAAA;AAAP,QAAeL,KAAK,CAACM,KAAzB;AACAF,IAAAA,GAAG,GAAG,KAAKG,eAAL,CAAqBH,GAArB,CAAN;AACAC,IAAAA,GAAG,GAAG,KAAKE,eAAL,CAAqBF,GAArB,CAAN;AACA,UAAMG,OAAgB,GAAG;AACvBC,MAAAA,QAAQ,EAAE;AAAEC,QAAAA,WAAW,EAAE,CAACN,GAAD,EAAMC,GAAN,CAAf;AAA2BM,QAAAA,IAAI,EAAE;AAAjC,OADa;AAEvBC,MAAAA,UAAU,EAAE;AAAEC,QAAAA,IAAI,EAAG,GAAET,GAAI,KAAIC,GAAI;AAAvB,OAFW;AAGvBM,MAAAA,IAAI,EAAE;AAHiB,KAAzB;;AAKA,gCAAI,KAAKG,cAAT,iDAAI,qBAAqBC,2BAAzB,EAAsD;AACpD,aAAOC,OAAO,CAACC,OAAR,CAAgB;AACrBN,QAAAA,IAAI,EAAE,mBADe;AAErBO,QAAAA,QAAQ,EAAE,CAACV,OAAD,CAFW;AAGrBW,QAAAA,kBAAkB,EAAEX;AAHC,OAAhB,CAAP;AAKD;;AAED,WAAOQ,OAAO,CAACC,OAAR,CAAgB;AACrBb,MAAAA,GADqB;AAErBC,MAAAA,GAFqB;AAGrBQ,MAAAA,IAAI,EAAEL,OAAO,CAACI,UAAR,CAAmBC,IAHJ;AAIrBM,MAAAA,kBAAkB,EAAEX;AAJC,KAAhB,CAAP;AAMD;AAED;AACF;AACA;;;AACEY,EAAAA,MAAM,CAACpB,KAAD,EAAqD;AACzD,WAAO,KAAKC,qBAAL,CAA2BD,KAAK,CAACE,IAAjC,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACED,EAAAA,qBAAqB,CAACoB,MAAD,EAAiD;AACpE,QAAIb,OAAJ;;AACA,QAAI;AACFA,MAAAA,OAAO,GAAG;AACRC,QAAAA,QAAQ,EAAE;AACRC,UAAAA,WAAW,EAAE,2BAAc,gCAAmBW,MAAnB,CAAd,CADL;AAERV,UAAAA,IAAI,EAAE;AAFE,SADF;AAKRC,QAAAA,UAAU,EAAE;AACVU,UAAAA,KAAK,EAAED;AADG;AALJ,OAAV;AASD,KAVD,CAUE,OAAOE,CAAP,EAAU;AACV,aAAOP,OAAO,CAACC,OAAR,CAAgB;AAAEC,QAAAA,QAAQ,EAAE,EAAZ;AAAgBP,QAAAA,IAAI,EAAE;AAAtB,OAAhB,CAAP;AACD;;AACD,WAAOK,OAAO,CAACC,OAAR,CAAgB;AAAEC,MAAAA,QAAQ,EAAE,CAACV,OAAD,CAAZ;AAAuBG,MAAAA,IAAI,EAAE;AAA7B,KAAhB,CAAP;AACD;;AAEDJ,EAAAA,eAAe,CAACiB,MAAD,EAAyB;AACtC,UAAMC,WAAW,GAAG,MAApB;AACA,WAAOC,IAAI,CAACC,KAAL,CAAWH,MAAM,GAAGC,WAApB,IAAmCA,WAA1C;AACD;;AApEiD","sourcesContent":["import { toCoordinates, fromLatFirstString } from \"@conveyal/lonlat\";\n\n// Prettier does not support typescript annotation\n// eslint-disable-next-line prettier/prettier\nimport type { Feature } from \"geojson\";\nimport type { AutocompleteQuery, ReverseQuery, SearchQuery } from \"..\";\nimport type  { MultiGeocoderResponse, SingleOrMultiGeocoderResponse } from \"./types\"\n\nimport Geocoder from \"./abstract-geocoder\";\n\n\n/**\n * An implementation that doesn't use an API for geocoding. Merely allows\n * clicking on the map and finding GPS coordinates by typing them in.\n *\n * @extends Geocoder\n */\nexport default class NoApiGeocoder extends Geocoder {\n  /**\n   * Use coordinate string parser.\n   */\n  autocomplete(query: AutocompleteQuery): Promise<MultiGeocoderResponse> {\n    return this.parseCoordinateString(query.text);\n  }\n\n  /**\n   * Always return the lat/lon.\n   */\n  reverse(query: ReverseQuery): Promise<SingleOrMultiGeocoderResponse> {\n    let { lat, lon } = query.point;\n    lat = this.roundGPSDecimal(lat);\n    lon = this.roundGPSDecimal(lon);\n    const feature: Feature = {\n      geometry: { coordinates: [lat, lon], type: \"Point\" },\n      properties: { name: `${lat}, ${lon}` },\n      type: \"Feature\"\n    };\n    if (this.geocoderConfig?.reverseUseFeatureCollection) {\n      return Promise.resolve({\n        type: \"FeatureCollection\",\n        features: [feature],\n        rawGeocodedFeature: feature\n      });\n    }\n\n    return Promise.resolve({\n      lat,\n      lon,\n      name: feature.properties.name,\n      rawGeocodedFeature: feature\n    })\n  }\n\n  /**\n   * Use coordinate string parser.\n   */\n  search(query: SearchQuery): Promise<MultiGeocoderResponse> {\n    return this.parseCoordinateString(query.text);\n  }\n\n  /**\n   * Attempt to parse the input as a GPS coordinate. If parseable, return a\n   * feature.\n   */\n  parseCoordinateString(string: string): Promise<MultiGeocoderResponse> {\n    let feature;\n    try {\n      feature = {\n        geometry: {\n          coordinates: toCoordinates(fromLatFirstString(string)),\n          type: \"Point\"\n        },\n        properties: {\n          label: string\n        }\n      };\n    } catch (e) {\n      return Promise.resolve({ features: [], type: \"FeatureCollection\" });\n    }\n    return Promise.resolve({ features: [feature], type: \"FeatureCollection\" });\n  }\n\n  roundGPSDecimal(number: number): number {\n    const roundFactor = 100000;\n    return Math.round(number * roundFactor) / roundFactor;\n  }\n}\n"],"file":"noapi.js"}