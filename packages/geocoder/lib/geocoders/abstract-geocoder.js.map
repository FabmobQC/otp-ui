{"version":3,"sources":["../../src/geocoders/abstract-geocoder.ts"],"names":["Geocoder","constructor","geocoderApi","geocoderConfig","api","autocomplete","query","getAutocompleteQuery","then","rewriteAutocompleteResponse","bind","getLocationFromGeocodedFeature","feature","geometry","type","location","coordinates","name","properties","label","rawGeocodedFeature","Promise","resolve","reject","Error","reverse","getReverseQuery","rewriteReverseResponse","search","getSearchQuery","rewriteSearchResponse","apiKey","baseUrl","boundary","focusPoint","options","url","undefined","format","reverseUseFeatureCollection","response"],"mappings":"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","sourcesContent":["import { fromCoordinates } from \"@conveyal/lonlat\";\n\n// Prettier does not support typescript annotation\n// eslint-disable-next-line prettier/prettier\nimport type { Feature } from \"geojson\"\nimport type { GeocoderConfig, ReverseQuery, AutocompleteQuery, SearchQuery, MultiGeocoderResponse, SingleGeocoderResponse, SingleOrMultiGeocoderResponse } from \"./types\"\n\n/**\n * The exact format of the Geocoder response depends on the specific geocoder implementation\n */\ntype GeocoderAPI = {\n  autocomplete: (query: AutocompleteQuery) => Promise<unknown>;\n  reverse: (query: ReverseQuery) => Promise<unknown>;\n  search: (query: SearchQuery) => Promise<unknown>;\n};\n\n/**\n * Create customized geocoder functions given a certain geocoding API, the\n * config for the geocoder and response rewrite functions specific to this\n * application. Any geocoder API that is added is expected to have an API that\n * behaves very closely to https://github.com/conveyal/isomorphic-mapzen-search\n */\nexport default class Geocoder {\n  geocoderConfig: GeocoderConfig;\n\n  api: GeocoderAPI;\n\n  constructor(geocoderApi?: GeocoderAPI, geocoderConfig?: GeocoderConfig) {\n    this.api = geocoderApi;\n    this.geocoderConfig = geocoderConfig;\n  }\n\n  /**\n   * Perform an autocomplete query, e.g. using partial text of a possible\n   * address or POI, attempt to find possible matches.\n   */\n  autocomplete(query: AutocompleteQuery): Promise<MultiGeocoderResponse> {\n    return this.api\n      .autocomplete(this.getAutocompleteQuery(query))\n      .then(this.rewriteAutocompleteResponse.bind(this));\n  }\n\n  /**\n   * Get an application-specific data structure from a given feature. The\n   * feature is either the result of an autocomplete or a search query. This\n   * function returns a Promise because sometimes an asynchronous action\n   * needs to be taken to translate a feature into a location. For example,\n   * the ArcGIS autocomplete service returns results that lack full address\n   * data and GPS and it is expected that an extra call to the `search` API is\n   * done to obtain that detailed data.\n   */\n  getLocationFromGeocodedFeature(\n    feature: Feature\n  ): Promise<SingleGeocoderResponse> {\n    if (feature.geometry.type === \"Point\") {\n      const location: SingleGeocoderResponse = {\n        ...fromCoordinates(feature.geometry.coordinates),\n        name: feature.properties.label,\n        rawGeocodedFeature: feature\n      };\n      return Promise.resolve(location);\n    }\n    return Promise.reject(new Error(\"Feature is not of type Point.\"));\n  }\n\n  /**\n   * Do a reverse-geocode, i.e. get address information and attributes given a\n   * GPS coordinate.\n   */\n  reverse(query: ReverseQuery): Promise<MultiGeocoderResponse | SingleGeocoderResponse> {\n    return this.api\n      .reverse(this.getReverseQuery(query))\n      .then(this.rewriteReverseResponse.bind(this));\n  }\n\n  /**\n   * Perform a search query. A search query is different from autocomplete in\n   * that it is assumed that the text provided is more or less a complete\n   * well-formatted address.\n   */\n  search(query: SearchQuery): Promise<MultiGeocoderResponse> {\n    return this.api\n      .search(this.getSearchQuery(query))\n      .then(this.rewriteSearchResponse.bind(this));\n  }\n\n  /**\n   * Default autocomplete query generator\n   */\n  getAutocompleteQuery(query: AutocompleteQuery): AutocompleteQuery {\n    const {\n      apiKey,\n      baseUrl,\n      boundary,\n      focusPoint,\n      options\n    } = this.geocoderConfig;\n    return {\n      apiKey,\n      boundary,\n      focusPoint,\n      options,\n      // TODO: Hard coding something like an /autocomplete endpoint path in here is not very abstract.\n      url: baseUrl ? `${baseUrl}/autocomplete` : undefined,\n      ...query\n    };\n  }\n\n  /**\n   * Default reverse query generator\n   */\n  getReverseQuery(query: ReverseQuery): ReverseQuery {\n    const { apiKey, baseUrl, options } = this.geocoderConfig;\n    return {\n      apiKey,\n      format: !this.geocoderConfig?.reverseUseFeatureCollection, // keep result as GeoJSON if we're supposed to have a feature collection\n      options,\n      url: baseUrl ? `${baseUrl}/reverse` : undefined,\n      ...query\n    };\n  }\n\n  /**\n   * Default search query generator.\n   */\n  getSearchQuery(query: SearchQuery): SearchQuery {\n    const {\n      apiKey,\n      baseUrl,\n      boundary,\n      focusPoint,\n      options\n    } = this.geocoderConfig;\n    return {\n      apiKey,\n      boundary,\n      focusPoint,\n      options,\n      url: baseUrl ? `${baseUrl}/search` : undefined,\n      format: false, // keep as returned GeoJSON,\n      ...query\n    };\n  }\n\n  /**\n   * Default rewriter for autocomplete responses\n   * Response type is unknown because it depends on the specific Geocoder implementation.\n   */\n  rewriteAutocompleteResponse(response: unknown): MultiGeocoderResponse {\n    return response as MultiGeocoderResponse;\n  }\n\n  /**\n   * Default rewriter for reverse responses\n   * Response type is unknown because it depends on the specific Geocoder implementation.\n   * Reverse response can use either Single or MultiGeocoderResponse based on GeocoderConfig.reverseUseFeatureCollection\n   */\n  rewriteReverseResponse(response: unknown): SingleOrMultiGeocoderResponse {\n    return response as SingleOrMultiGeocoderResponse;\n  }\n\n  /**\n   * Default rewriter for search responses\n   * Response type is unknown because it depends on the specific Geocoder implementation.\n   */\n  rewriteSearchResponse(response: unknown): MultiGeocoderResponse {\n    return response as MultiGeocoderResponse;\n  }\n}\n"],"file":"abstract-geocoder.js"}