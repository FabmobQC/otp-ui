{"version":3,"sources":["../../../src/apis/photon/index.ts"],"names":["AUTOCOMPLETE_URL","GEOCODE_URL","REVERSE_URL","GeocoderException","message","name","run","options","query","url","fetch","then","res","json","autocomplete","boundary","focusPoint","size","text","limit","q","lat","lon","toString","country","rect","in","minLon","minLat","maxLon","maxLat","join","search","Promise","resolve","items","reverse","point"],"mappings":"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","sourcesContent":["import { normalize } from \"@conveyal/lonlat\";\nimport { stringify } from \"querystring\";\n\n// Prettier does not support typescript annotation\n// eslint-disable-next-line prettier/prettier\nimport type { LonLatOutput } from \"@conveyal/lonlat\"\nimport type { AutocompleteQuery, ReverseQuery, SearchQuery } from \"../../geocoders/types\"\nimport type { PhotonResponse } from \"./types\";\n\nconst AUTOCOMPLETE_URL =\n    \"https://photon.komoot.io/api\";\nconst GEOCODE_URL = \"https://photon.komoot.io/api\";\nconst REVERSE_URL = \"https://photon.komoot.io/reverse\";\n\ntype PhotonQuery = {\n  lon?: string;\n  lat?: string;\n  in?: string;\n  lang?: string;\n  limit?: number | string;\n  politicalView?: string;\n  q?: string;\n  qq?: string;\n  show?: string;\n};\n\n// These types are standardized for the other geocoders in this library.\n// Perhaps we could extract them out somewhere and reuse them in the other libraries?\ntype PhotonFetchArgs = {\n  options: RequestInit; // Built-in Typing\n  query: PhotonQuery;\n  url: string;\n};\n\nfunction GeocoderException(message: string) {\n  this.message = message;\n  this.name = \"GeocoderException\";\n}\n\nfunction run({ options, query, url }: PhotonFetchArgs): Promise<PhotonResponse> {\n  return fetch(`${url}?${stringify(query)}`, options).then(res => res.json());\n}\n\n/**\n * Search for an address using\n * Komoot's Photon {@link https://github.com/komoot/photon}\n * service.\n *\n * @param  {Object} $0\n * @param  {Object} $0.boundary\n * @param  {Object} $0.focusPoint\n * @param  {Object} $0.options                    options to pass to fetch (e.g., custom headers)\n * @param  {number} [$0.size=20]\n * @param  {string} $0.text                       query text\n * @return {Promise}                              A Promise that'll get resolved with the autocomplete result\n */\nasync function autocomplete({\n  boundary,\n  focusPoint,\n  options,\n  size = 20,\n  text\n}: AutocompleteQuery): Promise<PhotonResponse> {\n  // build query\n  const query: PhotonQuery = { limit: size, q: text };\n\n  if (focusPoint) {\n    const { lat, lon }: LonLatOutput = normalize(focusPoint);\n    query.lat = lat.toString();\n    query.lon = lon.toString();\n    const res = await run({\n      options,\n      query,\n      url: AUTOCOMPLETE_URL\n    });\n    return res\n  }\n  if (boundary) {\n    const { country, rect } = boundary;\n    if (country) query.in = `countryCode:${country}`;\n    if (rect) {\n      query.in = `bbox:${[\n        rect.minLon,\n        rect.minLat,\n        rect.maxLon,\n        rect.maxLat\n      ].join(\",\")}`;\n    }\n  }\n\n  return run({\n    options,\n    query,\n    url: AUTOCOMPLETE_URL\n  });\n}\n\n/**\n * Search for an address using\n * Komoot's Photon {@link https://github.com/komoot/photon}\n * service.\n *\n * @param  {Object} $0\n * @param  {Object} $0.focusPoint\n * @param  {Object} $0.options                  options to pass to fetch (e.g., custom headers)\n * @param  {number} [$0.size=10]\n * @param  {string} $0.text                      The address text to query for\n * @return {Promise}                            A Promise that'll get resolved with search result\n */\nfunction search({\n  focusPoint,\n  options,\n  size = 10,\n  text\n}: SearchQuery): Promise<PhotonResponse> {\n  if (!text) return Promise.resolve({ items: [] });\n\n  const query: PhotonQuery = {\n    limit: size,\n    q: text\n  };\n\n  if (focusPoint) {\n    const { lat, lon }: LonLatOutput = normalize(focusPoint);\n    query.lat = lat.toString();\n    query.lon = lon.toString();\n  }\n\n  return run({ options, query, url: GEOCODE_URL });\n}\n\n/**\n * Search for an address using\n * Komoot's Photon {@link https://github.com/komoot/photon} reverse\n * service.\n *\n * @param  {Object} $0\n * @param  {Object} $0.point\n * @param  {Object} $0.options                  options to pass to fetch (e.g., custom headers)\n * @return {Promise}                            A Promise that'll get resolved with search result\n */\nfunction reverse({ options, point }: ReverseQuery): Promise<PhotonResponse> {\n  const query: PhotonQuery = {\n  };\n\n  if (point) {\n    const { lat, lon }: LonLatOutput = normalize(point);\n    query.lat = lat.toString();\n    query.lon = lon.toString();\n  } else {\n    throw new GeocoderException(\"No point provided for reverse geocoder.\");\n  }\n\n  return run({ options, query, url: REVERSE_URL }).then(res => ({\n    ...res,\n    point\n  }));\n}\n\nexport { autocomplete, reverse, search };\n"],"file":"index.js"}