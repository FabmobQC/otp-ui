{"version":3,"sources":["../../../src/apis/here/index.ts"],"names":["AUTOCOMPLETE_URL","GEOCODE_URL","REVERSE_URL","GeocoderException","message","name","run","options","query","url","fetch","then","res","json","checkItemInBoundary","rect","position","maxLat","maxLon","minLat","minLon","lat","lng","autocomplete","apiKey","boundary","focusPoint","size","text","limit","q","show","lon","at","items","filter","country","in","join","search","Promise","resolve","reverse","point"],"mappings":"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","sourcesContent":["import { normalize } from \"@conveyal/lonlat\";\nimport { stringify } from \"querystring\";\n\n// Prettier does not support typescript annotation\n// eslint-disable-next-line prettier/prettier\nimport type { LonLatOutput } from \"@conveyal/lonlat\"\nimport type { AutocompleteQuery, ReverseQuery, SearchQuery } from \"../../geocoders/types\"\nimport type { Boundary, HereResponse, Item } from \"./types\";\n\nconst AUTOCOMPLETE_URL =\n  \"https://autosuggest.search.hereapi.com/v1/autosuggest\";\nconst GEOCODE_URL = \"https://geocode.search.hereapi.com/v1/geocode\";\nconst REVERSE_URL = \"https://revgeocode.search.hereapi.com/v1/revgeocode\";\n\ntype HereQuery = {\n  apiKey: string;\n  at?: string;\n  in?: string;\n  lang?: string;\n  limit?: number | string;\n  politicalView?: string;\n  q?: string;\n  qq?: string;\n  show?: string;\n};\n\n// These types are standardized for the other geocoders in this library.\n// Perhaps we could extract them out somewhere and reuse them in the other libraries?\ntype HereFetchArgs = {\n  options: RequestInit; // Built-in Typing\n  query: HereQuery;\n  url: string;\n};\n\nfunction GeocoderException(message: string) {\n  this.message = message;\n  this.name = \"GeocoderException\";\n}\n\nfunction run({ options, query, url }: HereFetchArgs): Promise<HereResponse> {\n  return fetch(`${url}?${stringify(query)}`, options).then(res => res.json());\n}\n\nconst checkItemInBoundary = ({ rect }: Boundary) => ({ position }: Item) => {\n  if (!position) return true // Chain queries might not have position, ignore them\n  const { maxLat, maxLon, minLat, minLon } = rect\n  const { lat, lng } = position\n  return lng <= maxLon && lng >= minLon && lat <= maxLat && lat >= minLat\n}\n\n/**\n * Search for an address using\n * Here's {@link https://developer.here.com/documentation/geocoding-search-api/api-reference-swagger.html|Autocomplete}\n * service.\n *\n * @param  {Object} $0\n * @param  {string} $0.apiKey                     The Here API Key\n * @param  {Object} $0.boundary\n * @param  {Object} $0.focusPoint\n * @param  {Object} $0.options                    options to pass to fetch (e.g., custom headers)\n * @param  {number} [$0.size=20]\n * @param  {string} $0.text                       query text\n * @return {Promise}                              A Promise that'll get resolved with the autocomplete result\n */\nasync function autocomplete({\n  apiKey,\n  boundary,\n  focusPoint,\n  options,\n  size = 20,\n  text\n}: AutocompleteQuery): Promise<HereResponse> {\n  // build query\n  const query: HereQuery = { apiKey,  limit: size, q: text, show: \"details\" };\n\n  if (focusPoint) {\n    const { lat, lon }: LonLatOutput = normalize(focusPoint);\n    query.at = `${lat},${lon}`;\n    const res = await run({\n      options,\n      query,\n      url: AUTOCOMPLETE_URL\n    });\n    if (boundary?.rect) {\n      // HERE does not support a boundary when you use a focus point\n      // This workaround filters the results internally to the boundary\n      res.items = res.items.filter(checkItemInBoundary(boundary))\n    }\n    return res\n  }\n  if (boundary) {\n    const { country, rect } = boundary;\n    if (country) query.in = `countryCode:${country}`;\n    if (rect) {\n      query.in = `bbox:${[\n        rect.minLon,\n        rect.minLat,\n        rect.maxLon,\n        rect.maxLat\n      ].join(\",\")}`;\n    }\n  }\n\n  return run({\n    options,\n    query,\n    url: AUTOCOMPLETE_URL\n  });\n}\n\n/**\n * Search for an address using\n * HERE's {@link https://developer.here.com/documentation/geocoding-search-api/api-reference-swagger.html|Search}\n * service. NOTE: Here does not support a boundary for Search queries, unlike Pelias.\n *\n * @param  {Object} $0\n * @param  {string} $0.apiKey                    The Here API key\n * @param  {Object} $0.focusPoint\n * @param  {Object} $0.options                  options to pass to fetch (e.g., custom headers)\n * @param  {number} [$0.size=10]\n * @param  {string} $0.text                      The address text to query for\n * @return {Promise}                            A Promise that'll get resolved with search result\n */\nfunction search({\n  apiKey,\n  focusPoint,\n  options,\n  size = 10,\n  text\n}: SearchQuery): Promise<HereResponse> {\n  if (!text) return Promise.resolve({ items: [] });\n\n  const query: HereQuery = {\n    apiKey,\n    limit: size,\n    q: text\n  };\n\n  if (focusPoint) {\n    const { lat, lon }: LonLatOutput = normalize(focusPoint);\n    query.at = `${lat},${lon}`;\n  }\n\n  return run({ options, query, url: GEOCODE_URL });\n}\n\n/**\n * Search for an address using\n * HERE's {@link https://developer.here.com/documentation/geocoding-search-api/api-reference-swagger.html|Search}\n * service.\n *\n * @param  {Object} $0\n * @param  {string} $0.apiKey                   The Here API key\n * @param  {Object} $0.point\n * @param  {Object} $0.options                  options to pass to fetch (e.g., custom headers)\n * @return {Promise}                            A Promise that'll get resolved with search result\n */\nfunction reverse({ apiKey, options, point }: ReverseQuery): Promise<HereResponse> {\n  const query: HereQuery = {\n    apiKey\n  };\n\n  if (point) {\n    const { lat, lon }: LonLatOutput = normalize(point);\n    query.at = `${lat},${lon}`;\n  } else {\n    throw new GeocoderException(\"No point provided for reverse geocoder.\");\n  }\n\n  return run({ options, query, url: REVERSE_URL }).then(res => ({\n    ...res,\n    point\n  }));\n}\n\nexport { autocomplete, reverse, search };\n"],"file":"index.js"}