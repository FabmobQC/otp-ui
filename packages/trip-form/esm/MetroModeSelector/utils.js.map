{"version":3,"sources":["../../src/MetroModeSelector/utils.ts"],"names":["coreUtils","queryGen","TRANSIT_SUBMODES_AND_TRANSIT","aggregateModes","modeButtonDefinitions","reduce","array","combo","modes","forEach","mode","push","Array","filterModeDefitionsByKey","keys","filter","def","includes","key","convertModeSettingValue","setting","value","Number","type","populateSettingWithValue","values","convertedValue","extractModeSettingDefaultsToObject","modeSettings","prev","cur","inverseKey","high","low","checkIfModeSettingApplies","applicableMode","addSettingsToButton","settings","button","settingsForThisCombination","from","Set","setModeButtonEnabled","enabledKeys","modeButton","enabled"],"mappings":"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","sourcesContent":["import {\n  ModeButtonDefinition,\n  ModeSetting,\n  ModeSettingValues,\n  TransportMode\n} from \"@opentripplanner/types\";\n\nimport coreUtils from \"@opentripplanner/core-utils\";\n\nconst { queryGen } = coreUtils;\nconst { TRANSIT_SUBMODES_AND_TRANSIT } = queryGen;\n\n/**\n * Aggregates all the modes from the input mode button definitions\n * Should probably filter unique values, but it's not possible with a Set due to them being objects\n * @param modeButtonDefinitions Array of mode buttons\n * @returns All the (unique) modes from the buttons\n */\nexport function aggregateModes(\n  modeButtonDefinitions: ModeButtonDefinition[]\n): TransportMode[] {\n  return modeButtonDefinitions.reduce<Array<TransportMode>>((array, combo) => {\n    combo?.modes?.forEach(mode => array.push(mode));\n    return array;\n  }, new Array<TransportMode>());\n}\n\n/**\n * Filters mode buttons by list of keys, used to find enabled buttons.\n * TODO: Remove this function? Is it needed?\n * @param modeButtonDefinitions All mode definitions\n * @param keys List of keys of buttons to include\n * @returns Filtered list of buttons\n */\nexport function filterModeDefitionsByKey(\n  modeButtonDefinitions: ModeButtonDefinition[],\n  keys: string[]\n): ModeButtonDefinition[] {\n  return modeButtonDefinitions.filter(def => keys.includes(def.key));\n}\n\n/**\n * Sometimes we might get a string when we want a boolean or number,\n * since the URL state is stored as a string. This method helps convert\n * those values into the correct type.\n */\nexport function convertModeSettingValue(\n  setting: ModeSetting,\n  value: string | boolean | number\n): string | boolean | number {\n  // Assume the type of the output value based on the type of the default value.\n  if (setting.default) {\n    switch (typeof setting.default) {\n      case \"bigint\":\n      case \"number\":\n        return Number(value);\n      case \"boolean\":\n        return value === \"true\" || value === true;\n      default:\n        return value;\n    }\n  }\n  // In case no default is provided.\n  switch (setting.type) {\n    case \"CHECKBOX\":\n    case \"SUBMODE\":\n      return value === \"true\" || value === true;\n    case \"SLIDER\":\n      return Number(value);\n    default:\n      return value;\n  }\n}\n\n/**\n * Connects the mode setting value from a values object, where each key corresponds\n * to a mode setting in the modeSettings parameter.\n * @param modeSettings The mode setting with an empty `value` param\n * @param values An object containing setting values\n * @returns Mode Setting with populated value\n */\nexport const populateSettingWithValue = (values: ModeSettingValues) => (\n  setting: ModeSetting\n): ModeSetting => {\n  const value = values[setting.key];\n  const convertedValue = convertModeSettingValue(setting, value);\n  return {\n    ...setting,\n    value: convertedValue as string & number & boolean\n  };\n};\n\n/**\n * Extracts the defaults from each mode setting into an object\n * where the keys correspond with the keys from the mode setting.\n * @param modeSetting Mode settings with `default`s populated\n * @returns Object containing just the keys and values from defaults\n */\nexport function extractModeSettingDefaultsToObject(\n  modeSettings: ModeSetting[]\n): ModeSettingValues {\n  return modeSettings?.reduce((prev, cur) => {\n    prev[cur.key] = cur.default;\n    if (cur.type === \"SLIDER\" && cur.inverseKey && cur.default) {\n      prev[cur.inverseKey] = cur.high - cur.default + cur.low;\n    }\n    return prev;\n  }, {});\n}\n\n/**\n * This function is used to apply the ModeSettings to the ModeButtons by checking\n * each setting against all the transport modes in the button. It also handles the special\n * case of a \"TRANSIT\" mode setting, which can apply to all of the different possible TRANSIT_MODES.\n * @param setting Mode setting to check\n * @param mode TransportMode to check against\n * @returns Whether this mode setting applies to this TransportMode\n */\nexport function checkIfModeSettingApplies(\n  setting: ModeSetting,\n  mode: TransportMode\n): boolean {\n  if (setting.applicableMode === \"TRANSIT\") {\n    return TRANSIT_SUBMODES_AND_TRANSIT.includes(mode.mode);\n  }\n  return setting.applicableMode === mode.mode;\n}\n\n/**\n * Higher order function that can be used in `map` to add mode settings to mode button definitions.\n * @param settings Mode settings to be added to button\n * @returns Function that accepts a mode button definition, returning mode button def with populated settings\n */\nexport const addSettingsToButton = (settings: ModeSetting[]) => (\n  button: ModeButtonDefinition\n): ModeButtonDefinition => {\n  const settingsForThisCombination = Array.from(\n    new Set(\n      button.modes?.reduce<ModeSetting[]>((prev, mode) => {\n        return [\n          ...prev,\n          ...settings.filter(def => checkIfModeSettingApplies(def, mode))\n        ];\n      }, [])\n    )\n  );\n\n  return {\n    ...button,\n    modeSettings: settingsForThisCombination\n  };\n};\n/**\n * Provides a function that sets mode buttons' enabled state\n * Intended to be composed in a map\n * @param initialState Initial State object\n * @param enabledKeys Array of enabled keys, if not provided default to initial state\n * @returns Function that accepts mode button and returns a mode button with enabled key set\n */\nexport const setModeButtonEnabled = (enabledKeys: string[]) => (\n  modeButton: ModeButtonDefinition\n): ModeButtonDefinition => {\n  return {\n    ...modeButton,\n    enabled: enabledKeys.includes(modeButton.key)\n  };\n};\n"],"file":"utils.js"}