{"version":3,"sources":["../../src/MetroModeSelector/SubSettingsPane.tsx"],"names":["defaultMessages","defaultEnglishMessages","SubmodeGrid","styled","div","SettingsPanel","fieldset","SubSettingsCheckbox","CheckboxSelector","props","flexbox","FormLabelIconWrapper","span","ModeSettingRenderer","onChange","setting","intl","label","labelHigh","labelLow","type","key","labelWithIcon","icon","value","options","map","o","text","formatMessage","description","id","defaultMessage","high","low","step","SubSettingsPane","modeButton","onSettingUpdate","settingsNoSubmodes","settingsOnlySubmodes","modeSettings","reduce","accumulator","cur","push"],"mappings":"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","sourcesContent":["import { flatten } from \"flat\";\nimport { ModeButtonDefinition, ModeSetting } from \"@opentripplanner/types\";\nimport React, { ReactElement } from \"react\";\nimport { useIntl } from \"react-intl\";\nimport styled from \"styled-components\";\n\nimport CheckboxSelector from \"../CheckboxSelector\";\nimport DropdownSelector from \"../DropdownSelector\";\nimport SliderSelector from \"../SliderSelector\";\nimport generateModeButtonLabel, { generateModeSettingLabels } from \"./i18n\";\n\nimport defaultEnglishMessages from \"../../i18n/en-US.yml\";\n// HACK: We should flatten the messages loaded above because\n// the YAML loaders behave differently between webpack and our version of jest:\n// - the yaml loader for webpack returns a nested object,\n// - the yaml loader for jest returns messages with flattened ids.\nexport const defaultMessages: Record<string, string> = flatten(\n  defaultEnglishMessages\n);\n\nconst SubmodeGrid = styled.div`\n  display: grid;\n  grid-column: span 2;\n  grid-template-columns: 1fr 1fr;\n  width: 100%;\n`;\n\nconst SettingsPanel = styled.fieldset`\n  border: none;\n  pointer-events: auto;\n\n  div {\n    padding: 5px 0;\n  }\n  .wide {\n    grid-column: span 2;\n  }\n  .slim {\n    font-size: 125%;\n    font-weight: 125%;\n  }\n\n  legend {\n    font-size: 1.5em;\n    margin-bottom: 0.5rem;\n    padding-top: 15px;\n  }\n`;\n\nexport const SubSettingsCheckbox = styled(CheckboxSelector)<{\n  flexbox: boolean;\n}>`\n  ${props => (props.flexbox ? \"align-items: baseline;\" : \"\")};\n  display: ${props => (props.flexbox ? \"flex\" : \"inherit\")};\n  margin-left: 4px;\n\n  input {\n    flex-shrink: 0;\n  }\n`;\n\nconst FormLabelIconWrapper = styled.span`\n  align-items: baseline;\n  display: flex;\n  gap: 4px;\n  svg {\n    width: 16px;\n    height: 16px;\n    display: inline-block;\n    margin-bottom: 4px;\n    vertical-align: middle;\n    overflow: hidden;\n  }\n`;\n\n/**\n * Renders a mode setting definition\n * @param onChange function for when the value changes, and the setting to be rendered\n * @returns JSX Element to render\n */\nexport const ModeSettingRenderer = ({\n  onChange,\n  setting\n}: {\n  onChange: (QueryParamChangeEvent) => void;\n  setting: ModeSetting;\n}): JSX.Element => {\n  const intl = useIntl();\n  const { label, labelHigh, labelLow } = generateModeSettingLabels(\n    setting.type,\n    setting.key,\n    intl,\n    setting.label\n  );\n  const labelWithIcon =\n    \"icon\" in setting ? (\n      <FormLabelIconWrapper>\n        {setting.icon && <div role=\"none\">{setting.icon}</div>}\n        <div>{label}</div>\n      </FormLabelIconWrapper>\n    ) : (\n      label\n    );\n\n  switch (setting.type) {\n    case \"CHECKBOX\":\n    case \"SUBMODE\":\n      return (\n        <SubSettingsCheckbox\n          flexbox={setting.type === \"SUBMODE\"}\n          label={labelWithIcon}\n          name={setting.key}\n          onChange={onChange}\n          value={setting.value}\n        />\n      );\n    case \"DROPDOWN\":\n      return (\n        <DropdownSelector\n          label={labelWithIcon}\n          name={setting.key}\n          onChange={onChange}\n          options={setting.options.map(o => ({\n            ...o,\n            text: intl.formatMessage({\n              description: `Metro Mode Selector Setting (${setting.key}) Option Label (${o.value})`,\n              id: `otpUi.ModeSelector.settings.${setting.key}-options-${o.value}`,\n              defaultMessage: o.text\n            })\n          }))}\n          value={setting.value}\n        />\n      );\n    case \"SLIDER\":\n      return (\n        <SliderSelector\n          label={label}\n          labelHigh={labelHigh}\n          labelLow={labelLow}\n          max={setting.high}\n          min={setting.low}\n          name={setting.key}\n          onChange={onChange}\n          step={setting.step}\n          value={setting.value}\n        />\n      );\n    default:\n      return null;\n  }\n};\n\ninterface Props {\n  modeButton: ModeButtonDefinition;\n  onSettingUpdate: (QueryParamChangeEvent) => void;\n}\nexport default function SubSettingsPane({\n  modeButton,\n  onSettingUpdate\n}: Props): ReactElement {\n  const intl = useIntl();\n  const label = generateModeButtonLabel(modeButton.key, intl, modeButton.label);\n\n  // Split the mode settings out based on whether they're submodes or not\n  // This is so we can display submodes in a grid at the top\n  const {\n    settingsNoSubmodes,\n    settingsOnlySubmodes\n  } = modeButton.modeSettings.reduce(\n    (accumulator, cur) => {\n      if (cur.type === \"SUBMODE\") {\n        accumulator.settingsOnlySubmodes.push(cur);\n      } else {\n        accumulator.settingsNoSubmodes.push(cur);\n      }\n      return accumulator;\n    },\n    { settingsNoSubmodes: [], settingsOnlySubmodes: [] }\n  );\n\n  return (\n    <SettingsPanel>\n      <legend>\n        <span id={`metro-mode-selector-${modeButton.key}-button-label`}>\n          {label}\n        </span>\n      </legend>\n      <SubmodeGrid>\n        {settingsOnlySubmodes.map(setting => (\n          <ModeSettingRenderer\n            key={setting.key}\n            onChange={onSettingUpdate}\n            setting={setting}\n          />\n        ))}\n      </SubmodeGrid>\n      {settingsNoSubmodes.map(setting => (\n        <ModeSettingRenderer\n          key={setting.key}\n          onChange={onSettingUpdate}\n          setting={setting}\n        />\n      ))}\n    </SettingsPanel>\n  );\n}\n"],"file":"SubSettingsPane.js"}