{"version":3,"sources":["../../src/MetroModeSelector/utils.ts"],"names":["queryGen","coreUtils","TRANSIT_SUBMODES_AND_TRANSIT","aggregateModes","modeButtonDefinitions","reduce","array","combo","modes","forEach","mode","push","Array","filterModeDefitionsByKey","keys","filter","def","includes","key","convertModeSettingValue","setting","value","default","Number","type","populateSettingWithValue","values","convertedValue","extractModeSettingDefaultsToObject","modeSettings","prev","cur","inverseKey","high","low","checkIfModeSettingApplies","applicableMode","addSettingsToButton","settings","button","settingsForThisCombination","from","Set","setModeButtonEnabled","enabledKeys","modeButton","enabled"],"mappings":"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","sourcesContent":["import {\n  ModeButtonDefinition,\n  ModeSetting,\n  ModeSettingValues,\n  TransportMode\n} from \"@opentripplanner/types\";\n\nimport coreUtils from \"@opentripplanner/core-utils\";\n\nconst { queryGen } = coreUtils;\nconst { TRANSIT_SUBMODES_AND_TRANSIT } = queryGen;\n\n/**\n * Aggregates all the modes from the input mode button definitions\n * Should probably filter unique values, but it's not possible with a Set due to them being objects\n * @param modeButtonDefinitions Array of mode buttons\n * @returns All the (unique) modes from the buttons\n */\nexport function aggregateModes(\n  modeButtonDefinitions: ModeButtonDefinition[]\n): TransportMode[] {\n  return modeButtonDefinitions.reduce<Array<TransportMode>>((array, combo) => {\n    combo?.modes?.forEach(mode => array.push(mode));\n    return array;\n  }, new Array<TransportMode>());\n}\n\n/**\n * Filters mode buttons by list of keys, used to find enabled buttons.\n * TODO: Remove this function? Is it needed?\n * @param modeButtonDefinitions All mode definitions\n * @param keys List of keys of buttons to include\n * @returns Filtered list of buttons\n */\nexport function filterModeDefitionsByKey(\n  modeButtonDefinitions: ModeButtonDefinition[],\n  keys: string[]\n): ModeButtonDefinition[] {\n  return modeButtonDefinitions.filter(def => keys.includes(def.key));\n}\n\n/**\n * Sometimes we might get a string when we want a boolean or number,\n * since the URL state is stored as a string. This method helps convert\n * those values into the correct type.\n */\nexport function convertModeSettingValue(\n  setting: ModeSetting,\n  value: string | boolean | number\n): string | boolean | number {\n  // Assume the type of the output value based on the type of the default value.\n  if (setting.default) {\n    switch (typeof setting.default) {\n      case \"bigint\":\n      case \"number\":\n        return Number(value);\n      case \"boolean\":\n        return value === \"true\" || value === true;\n      default:\n        return value;\n    }\n  }\n  // In case no default is provided.\n  switch (setting.type) {\n    case \"CHECKBOX\":\n    case \"SUBMODE\":\n      return value === \"true\" || value === true;\n    case \"SLIDER\":\n      return Number(value);\n    default:\n      return value;\n  }\n}\n\n/**\n * Connects the mode setting value from a values object, where each key corresponds\n * to a mode setting in the modeSettings parameter.\n * @param modeSettings The mode setting with an empty `value` param\n * @param values An object containing setting values\n * @returns Mode Setting with populated value\n */\nexport const populateSettingWithValue = (values: ModeSettingValues) => (\n  setting: ModeSetting\n): ModeSetting => {\n  const value = values[setting.key];\n  const convertedValue = convertModeSettingValue(setting, value);\n  return {\n    ...setting,\n    value: convertedValue as string & number & boolean\n  };\n};\n\n/**\n * Extracts the defaults from each mode setting into an object\n * where the keys correspond with the keys from the mode setting.\n * @param modeSetting Mode settings with `default`s populated\n * @returns Object containing just the keys and values from defaults\n */\nexport function extractModeSettingDefaultsToObject(\n  modeSettings: ModeSetting[]\n): ModeSettingValues {\n  return modeSettings?.reduce((prev, cur) => {\n    prev[cur.key] = cur.default;\n    if (cur.type === \"SLIDER\" && cur.inverseKey && cur.default) {\n      prev[cur.inverseKey] = cur.high - cur.default + cur.low;\n    }\n    return prev;\n  }, {});\n}\n\n/**\n * This function is used to apply the ModeSettings to the ModeButtons by checking\n * each setting against all the transport modes in the button. It also handles the special\n * case of a \"TRANSIT\" mode setting, which can apply to all of the different possible TRANSIT_MODES.\n * @param setting Mode setting to check\n * @param mode TransportMode to check against\n * @returns Whether this mode setting applies to this TransportMode\n */\nexport function checkIfModeSettingApplies(\n  setting: ModeSetting,\n  mode: TransportMode\n): boolean {\n  if (setting.applicableMode === \"TRANSIT\") {\n    return TRANSIT_SUBMODES_AND_TRANSIT.includes(mode.mode);\n  }\n  return setting.applicableMode === mode.mode;\n}\n\n/**\n * Higher order function that can be used in `map` to add mode settings to mode button definitions.\n * @param settings Mode settings to be added to button\n * @returns Function that accepts a mode button definition, returning mode button def with populated settings\n */\nexport const addSettingsToButton = (settings: ModeSetting[]) => (\n  button: ModeButtonDefinition\n): ModeButtonDefinition => {\n  const settingsForThisCombination = Array.from(\n    new Set(\n      button.modes?.reduce<ModeSetting[]>((prev, mode) => {\n        return [\n          ...prev,\n          ...settings.filter(def => checkIfModeSettingApplies(def, mode))\n        ];\n      }, [])\n    )\n  );\n\n  return {\n    ...button,\n    modeSettings: settingsForThisCombination\n  };\n};\n/**\n * Provides a function that sets mode buttons' enabled state\n * Intended to be composed in a map\n * @param initialState Initial State object\n * @param enabledKeys Array of enabled keys, if not provided default to initial state\n * @returns Function that accepts mode button and returns a mode button with enabled key set\n */\nexport const setModeButtonEnabled = (enabledKeys: string[]) => (\n  modeButton: ModeButtonDefinition\n): ModeButtonDefinition => {\n  return {\n    ...modeButton,\n    enabled: enabledKeys.includes(modeButton.key)\n  };\n};\n"],"file":"utils.js"}