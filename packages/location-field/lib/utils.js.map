{"version":3,"sources":["../src/utils.ts"],"names":["layerDisplayMap","address","properties","housenumber","locality","name","neighbourhood","region_a","state","region","street","main","secondary","filter","item","join","venue","county","generateLabel","labelGenerator","layer","label","getCombinedLabel","addInParentheses","intl","mainText","extraText","formatMessage","id","detail","getGeocoderErrorMessage","errorText","geocoderUnreachableText","description","getMatchingLocations","places","text","length","lowerCaseText","toLowerCase","place","displayName","indexOf"],"mappings":"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","sourcesContent":["import { IntlShape } from \"react-intl\";\n\nimport { Properties, Label, UserLocationRenderData } from \"./types\";\n\n// A mapping of Pelias layers to display modes. The label generator will run the generator\n// based on the layer of the feature. Adding a new method to this mapping will support\n// more layer types with custom rendering.\nconst layerDisplayMap = {\n  address: (properties: Properties): Label => {\n    const {\n      housenumber,\n      locality,\n      name,\n      neighbourhood,\n      region_a: state,\n      region,\n      street\n    } = properties;\n    return {\n      // if the housenumber is available, combining that with the street can\n      // avoid duplicates which might be present in the name\n      main: housenumber ? `${housenumber} ${street}` : name,\n      secondary: [locality, neighbourhood, state || region]\n        .filter(item => !!item)\n        .join(\", \")\n    };\n  },\n  venue: (properties: Properties): Label => {\n    const {\n      locality,\n      name,\n      neighbourhood,\n      region_a: state,\n      street\n    } = properties;\n    return {\n      main: name,\n      secondary: [street, neighbourhood, locality, state]\n        .filter(item => !!item)\n        .join(\", \")\n    };\n  },\n  neighbourhood: (properties: Properties): Label => {\n    const { name, county, locality, region_a: state } = properties;\n    return {\n      main: name,\n      secondary: [county, locality, state].filter(item => !!item).join(\", \")\n    };\n  }\n};\n\n/**\n * Given a GeoJSON property with a layer, this method will use the layerDisplayMap\n * to generate an appropriate title subtitle pair, or return the label if the layer is\n * unknown.\n */\nexport const generateLabel = (properties: Properties): Label => {\n  const labelGenerator = layerDisplayMap[properties.layer];\n  if (!labelGenerator) return { main: properties.label };\n\n  return labelGenerator(properties);\n};\n\n/**\n * Generates a combined label from main and secondary for display in the main input field\n */\nexport const getCombinedLabel = (properties: Properties): string => {\n  const { main, secondary } = generateLabel(properties);\n  if (main && secondary) {\n    return `${main}, ${secondary}`;\n  }\n  return properties?.label || \"\";\n};\n\n/**\n * Helper method to append text in parentheses to some other text,\n * if the added text is not null or blank.\n */\nexport const addInParentheses = (\n  intl: IntlShape,\n  mainText: string,\n  extraText?: string\n): string => {\n  return extraText && extraText !== \"\"\n    ? intl.formatMessage(\n        { id: \"otpUi.LocationField.parenthesisFormat\" },\n        { detail: extraText, main: mainText }\n      )\n    : mainText;\n};\n\n/**\n * Helper function to assemble a geocoder error message.\n */\nexport const getGeocoderErrorMessage = (\n  intl: IntlShape,\n  errorText?: string\n): string => {\n  const geocoderUnreachableText = intl.formatMessage({\n    description: \"Geocoder unreachable status\",\n    id: \"otpUi.LocationField.geocoderUnreachable\"\n  });\n\n  return addInParentheses(intl, geocoderUnreachableText, errorText);\n};\n\n/**\n * Helper to compute matching user locations as you type.\n */\nexport function getMatchingLocations(\n  places: UserLocationRenderData[],\n  text: string\n): UserLocationRenderData[] {\n  if (places?.length > 0 && text && text !== \"\") {\n    const lowerCaseText = text.toLowerCase();\n    return places.filter(\n      place => place.displayName.toLowerCase().indexOf(lowerCaseText) !== -1\n    );\n  }\n\n  return [];\n}\n"],"file":"utils.js"}