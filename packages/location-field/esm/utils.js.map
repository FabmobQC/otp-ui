{"version":3,"sources":["../src/utils.ts"],"names":["layerDisplayMap","address","properties","housenumber","locality","name","neighbourhood","state","region_a","region","street","main","secondary","filter","item","join","venue","county","generateLabel","labelGenerator","layer","label","getCombinedLabel","addInParentheses","intl","mainText","extraText","formatMessage","id","detail","getGeocoderErrorMessage","errorText","geocoderUnreachableText","description","getMatchingLocations","places","text","length","lowerCaseText","toLowerCase","place","displayName","indexOf"],"mappings":"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","sourcesContent":["import { IntlShape } from \"react-intl\";\n\nimport { Properties, Label, UserLocationRenderData } from \"./types\";\n\n// A mapping of Pelias layers to display modes. The label generator will run the generator\n// based on the layer of the feature. Adding a new method to this mapping will support\n// more layer types with custom rendering.\nconst layerDisplayMap = {\n  address: (properties: Properties): Label => {\n    const {\n      housenumber,\n      locality,\n      name,\n      neighbourhood,\n      region_a: state,\n      region,\n      street\n    } = properties;\n    return {\n      // if the housenumber is available, combining that with the street can\n      // avoid duplicates which might be present in the name\n      main: housenumber ? `${housenumber} ${street}` : name,\n      secondary: [locality, neighbourhood, state || region]\n        .filter(item => !!item)\n        .join(\", \")\n    };\n  },\n  venue: (properties: Properties): Label => {\n    const {\n      locality,\n      name,\n      neighbourhood,\n      region_a: state,\n      street\n    } = properties;\n    return {\n      main: name,\n      secondary: [street, neighbourhood, locality, state]\n        .filter(item => !!item)\n        .join(\", \")\n    };\n  },\n  neighbourhood: (properties: Properties): Label => {\n    const { name, county, locality, region_a: state } = properties;\n    return {\n      main: name,\n      secondary: [county, locality, state].filter(item => !!item).join(\", \")\n    };\n  }\n};\n\n/**\n * Given a GeoJSON property with a layer, this method will use the layerDisplayMap\n * to generate an appropriate title subtitle pair, or return the label if the layer is\n * unknown.\n */\nexport const generateLabel = (properties: Properties): Label => {\n  const labelGenerator = layerDisplayMap[properties.layer];\n  if (!labelGenerator) return { main: properties.label };\n\n  return labelGenerator(properties);\n};\n\n/**\n * Generates a combined label from main and secondary for display in the main input field\n */\nexport const getCombinedLabel = (properties: Properties): string => {\n  const { main, secondary } = generateLabel(properties);\n  if (main && secondary) {\n    return `${main}, ${secondary}`;\n  }\n  return properties?.label || \"\";\n};\n\n/**\n * Helper method to append text in parentheses to some other text,\n * if the added text is not null or blank.\n */\nexport const addInParentheses = (\n  intl: IntlShape,\n  mainText: string,\n  extraText?: string\n): string => {\n  return extraText && extraText !== \"\"\n    ? intl.formatMessage(\n        { id: \"otpUi.LocationField.parenthesisFormat\" },\n        { detail: extraText, main: mainText }\n      )\n    : mainText;\n};\n\n/**\n * Helper function to assemble a geocoder error message.\n */\nexport const getGeocoderErrorMessage = (\n  intl: IntlShape,\n  errorText?: string\n): string => {\n  const geocoderUnreachableText = intl.formatMessage({\n    description: \"Geocoder unreachable status\",\n    id: \"otpUi.LocationField.geocoderUnreachable\"\n  });\n\n  return addInParentheses(intl, geocoderUnreachableText, errorText);\n};\n\n/**\n * Helper to compute matching user locations as you type.\n */\nexport function getMatchingLocations(\n  places: UserLocationRenderData[],\n  text: string\n): UserLocationRenderData[] {\n  if (places?.length > 0 && text && text !== \"\") {\n    const lowerCaseText = text.toLowerCase();\n    return places.filter(\n      place => place.displayName.toLowerCase().indexOf(lowerCaseText) !== -1\n    );\n  }\n\n  return [];\n}\n"],"file":"utils.js"}